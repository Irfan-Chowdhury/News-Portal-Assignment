<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

        <title>CTG Online Portal</title>
    </head>

<body>
    <section class="container mt-3">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">
                    <img src="image/logo.jpg" alt="" width="80" height="60" class="d-inline-block align-text-top">
                    <span><strong>CTG Online Portal</strong></span>
                </a>
                <div class="collapse navbar-collapse" id="navbarScroll">
                    <ul class="navbar-nav me-auto my-2 my-lg-0 navbar-nav-scroll" style="--bs-scroll-height: 100px;">
                    </ul>
                    <form class="d-flex">
                        <div><a href="index.html">News</a></div>
                        &nbsp; &nbsp; &nbsp;
                        <div><a href="blog.html"> Blog</a></div>
                    </form>
                </div>
            </div>
        </nav>
        <hr>
    </section>

    <section class="container">
        <div class="accordion" id="accordionExample">
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingOne">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                        What's the difference between var, let and const ? 
                    </button>
                </h2>
                <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne"
                    data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <b>Var</b> <br>
                        Earlier only var is there and he is the king of variable declarations. But there are some issues associated with variables declared with var, though. That is why let and const introduced.
                        Var declarations are globally scoped or function scoped. That means if a variable is declared with var outside a function then it is in the global scope(accessible anywhere). Otherwise, if they are inside a function we can only access them inside the function.
                        Let’s look at the example to understand further. <br><br>

                        <b>Let</b> <br>
                        It’s an enhanced version of var, it solves all the problems that come with the var keyword. Like, let is a block-scoped variable and we cannot re-declared but can be updated(re-assigned). You’ll see in the below example as it shows that let is preferable over var.
                        Here we can see that we can update the variable but cannot be re-declared that is why it throws an error and variables that are declared with let and const in block statements( if-else, while, for loop, etc..) are not accessible anywhere.
                        These facts make let a better choice than var. As it solves both the issues that came with var.
                        <br><br>

                        <b>Const</b> <br>
                        Const declarations share some similarities with let declarations, but const variables cannot be updated or re-declared. It maintains the constant values.
                        Unlike var and let, if we are using const then it must be initialized at the same time when we declared the variable.
                        Let’s see with an example:-
                        Apart from this, const behaves exactly the same as let. I personally prefer let and const over var. But there are some cases when var is also useful as it is hoisted to the top and initialized with a value of ‘undefined’.

                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingTwo">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                        What's the difference between regular functions and arrow functions ?
                    </button>
                </h2>
                <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                    data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                            <b>Regular function</b> <br>
                            Inside of a regular JavaScript function, this value (aka the execution context) is dynamic.
                            
                            The dynamic context means that the value of this depends on how the function is invoked. In JavaScript, there are 4 ways you can invoke a regular function.
                            
                            During a simple invocation the value of this equals to the global object (or undefined if the function runs in strict mode):
                            
                            function myFunction() {
                              console.log(this);
                            }
                            // Simple invocation
                            myFunction(); // logs global object (window)
                            During a method invocation the value of this is the object owning the method:
                            
                            const myObject = {
                              method() {
                                console.log(this);
                              }
                            };
                            // Method invocation
                            myObject.method(); // logs myObject
                            During an indirect invocation using myFunc.call(thisVal, arg1, ..., argN) or myFunc.apply(thisVal, [arg1, ..., argN]) the value of this equals to the first argument:
                            
                            function myFunction() {
                              console.log(this);
                            }
                            const myContext = { value: 'A' };
                            myFunction.call(myContext);  // logs { value: 'A' }
                            myFunction.apply(myContext); // logs { value: 'A' }
                            During a constructor invocation using new keyword this equals to the newly created instance:
                            
                            function MyFunction() {
                              console.log(this);
                            }
                            new MyFunction(); // logs an instance of MyFunction
                            <br><br>

                            <b>Arrow function</b> <br>
                            The behavior of this inside of an arrow function differs considerably from the regular function's this behavior. The arrow function doesn't define its own execution context.
                            No matter how or where being executed, this value inside of an arrow function always equals this value from the outer function. In other words, the arrow function resolves this lexically.
                            In the following example, myMethod() is an outer function of callback() arrow function:

                            const myObject = {
                            myMethod(items) {
                                console.log(this); // logs myObject
                                const callback = () => {
                                console.log(this); // logs myObject
                                };
                                items.forEach(callback);
                            }
                            };
                            myObject.myMethod([1, 2, 3]); 
                            this value inside the arrow function callback() equals to this of the outer function myMethod().
                            this resolved lexically is one of the great features of arrow functions. When using callbacks inside methods you are sure the arrow function doesn't define its own this: no more const self = this or callback.bind(this) workarounds.
                            Contrary to a regular function, the indirect invocation of an arrow function using myArrowFunc.call(thisVal) or myArrowFunc.apply(thisVal) doesn't change the value of this: the context value is always resolved lexically.

                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingThree">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                        What's the difference between foreach, map, filter and find ?
                    </button>
                </h2>
                <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree"
                    data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <b>forEach</b><br>
                        forEach(), is used to execute the same code on every element in an array but does not change the array and it returns undefined.
                        Example: <br>
                        In the example below we would use .forEach() to iterate over an array of food and log that we would want to eat each of them. <br>
                        let food = ['mango','rice','pepper','pear'];
                        food.forEach(function(foodItem){ console.log('I want to eat '+foodItem);
                        }); <br>

                        <b>map()</b> <br>
                        .map() executes the same code on every element in an array and returns a new array with the updated elements. <br>
                        Example: <br>
                        In the example below we would use .map to iterate over the elements of the cost array and divide each element by 10, then assign our new array containing the new cost to the variable newCost.

                        let cost = [100,400,300,700];
                        let newCost = cost.map(function(costItem){ return costItem / 10;
                        });
                        console.log(newCost);

                        <br>
                        <b>filter():</b> <br>
                        .filter() checks every element in an array to see if it meets a certain criteria and returns a new array with the elements that return truthy for the criteria. <br>

                        Example: <br>
                        In the example below we would use .filter to return values that are less than 200.

                        let cost = [100,400,50,40,700];
                        let smallCost = cost.filter(function(costItem){ return costItem < 200
                        });
                        console.log(smallCost);

                        <br>
                        <b>find():</b> <br>
                        If you need the index of the found element in the array, use findIndex(). <br>
                        If you need to find the index of a value, use Array.prototype.indexOf(). (It's similar to findIndex(), but checks each element for equality with the value instead of using a testing function.) <br>
                        If you need to find if a value exists in an array, use Array.prototype.includes(). Again, it checks each element for equality with the value instead of using a testing function. <br>
                        If you need to find if any element satisfies the provided testing function, use Array.prototype.some(). <br>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingFour">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
                        Why need to use Template String ?
                    </button>
                </h2>
                <div id="collapseFour" class="accordion-collapse collapse" aria-labelledby="headingFour"
                    data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, for string interpolation with embedded expressions, and for special constructs called tagged templates. <br>

                        Template literals are sometimes informally called template strings, because they are used most commonly for string interpolation (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom tag function to perform whatever operations you want on the different parts of the template literal. <br>
                        Template literals are enclosed by backtick (`) characters instead of double or single quotes.

                        Along with having normal strings, template literals can also contain other parts called placeholders, which are embedded expressions delimited by a dollar sign and curly braces: ${expression}. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs string interpolation to do substitution of the placeholders and then concatenate the parts into a single string.

                        To supply a function of your own, precede the template literal with a function name; the result is called a tagged template. In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.

                        To escape a backtick in a template literal, put a backslash (\) before the backtick. <br>
                       
                        Multi-line strings <br>
                        Any newline characters inserted in the source are part of the template literal.

                        Using normal strings, you would have to use the following syntax in order to get multi-line strings:

                        console.log('string text line 1\n' +
                        'string text line 2');
                        // "string text line 1
                        // string text line 2"
                    </div>
                </div>
            </div>
        </div>
    </section>



    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</body>

</html>